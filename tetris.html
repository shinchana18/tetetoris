<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0,
               maximum-scale=1.0, user-scalable=no">
<title>Tetris</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  background: #000;
  color: #fff;
  height: 100%;
  font-family: monospace;
  overflow: hidden;
  touch-action: manipulation;
}
canvas, button { touch-action: manipulation; }

#wrap {
  display: grid;
  grid-template-columns: 200px 120px;
  height: 100%;
  justify-content: center;
  align-content: center;
}
canvas { background: #111; }

#side { padding: 8px; box-sizing: border-box; }

#ui {
  display: flex;
  justify-content: space-around;
  margin-top: 8px;
}
button { font-size: 16px; padding: 8px; }
</style>
</head>

<body>
<div id="wrap">
  <div>
    <canvas id="game" width="200" height="400"></canvas>
    <div id="ui">
      <button id="left">◀</button>
      <button id="rotate">⟳</button>
      <button id="right">▶</button>
      <button id="down">▼</button>
    </div>
  </div>

  <div id="side">
    SCORE<br><span id="score">0</span><br><br>
    LEVEL<br><span id="level">0</span><br><br>
    NEXT<br>
    <canvas id="next" width="80" height="80"></canvas><br>
    <button id="pause">PAUSE</button><br><br>
    <button id="restart">RESTART</button>
    <div id="over" style="display:none;margin-top:10px;">GAME OVER</div>
  </div>
</div>

<script>
/* ===== Safariズーム対策（button除外） ===== */
let lastTouchEnd=0;
document.addEventListener("touchend",e=>{
  if(e.target.closest("button"))return;
  const n=Date.now();
  if(n-lastTouchEnd<=300)e.preventDefault();
  lastTouchEnd=n;
},{passive:false});

/* ===== 定数 ===== */
const COLS=10,ROWS=20,BLOCK=20;
const ctx=document.getElementById("game").getContext("2d");

const COLORS=[null,"#0ff","#00f","#f80","#ff0","#0f0","#f00","#a0f"];
const SHAPES=[
 [],
 [[1,1,1,1]],
 [[2,0,0],[2,2,2]],
 [[0,0,3],[3,3,3]],
 [[4,4],[4,4]],
 [[0,5,5],[5,5,0]],
 [[0,6,0],[6,6,6]],
 [[7,7,0],[0,7,7]]
];

/* ===== 状態 ===== */
let board,piece,nextPiece;
let score,lines,level;
let paused=false,gameOver=false;
let softDrop=false,last=0,counter=0;

/* ===== 7種バッグ ===== */
let bag=[];
function refillBag(){
  bag=[1,2,3,4,5,6,7];
  for(let i=6;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [bag[i],bag[j]]=[bag[j],bag[i]];
  }
}
function getFromBag(){ if(!bag.length)refillBag(); return bag.pop(); }

/* ===== 初期化 ===== */
function reset(){
  board=Array.from({length:ROWS},()=>Array(COLS).fill(0));
  score=lines=level=0;
  refillBag();
  piece=newPiece();
  nextPiece=newPiece();
  paused=gameOver=false;
  document.getElementById("over").style.display="none";
  updateInfo(); drawNext();
}

/* ===== ピース ===== */
function newPiece(){
  const t=getFromBag();
  return {x:3,y:0,shape:SHAPES[t],type:t,rot:0};
}

/* ===== 衝突 ===== */
function collide(p,ox,oy){
  for(let y=0;y<p.shape.length;y++)
    for(let x=0;x<p.shape[y].length;x++)
      if(p.shape[y][x]){
        const nx=p.x+x+ox, ny=p.y+y+oy;
        if(nx<0||nx>=COLS||ny>=ROWS||board[ny]?.[nx])return true;
      }
  return false;
}

/* ===== 回転 ===== */
function rotateMatrix(m){
  return m[0].map((_,i)=>m.map(r=>r[i]).reverse());
}

/* ===== SRS簡易壁蹴り ===== */
const kicks=[[0,0],[-1,0],[1,0],[0,-1],[-2,0],[2,0]];
function tryRotate(){
  const r=rotateMatrix(piece.shape);
  for(const[kx,ky]of kicks){
    if(!collide({...piece,shape:r},kx,ky)){
      piece.shape=r;
      piece.x+=kx;
      piece.y+=ky;
      piece.rot=(piece.rot+1)%4;
      return;
    }
  }
}

/* ===== 固定 ===== */
function merge(){
  piece.shape.forEach((r,y)=>
    r.forEach((v,x)=>{ if(v)board[piece.y+y][piece.x+x]=piece.type; })
  );
}

/* ===== 消去 & スコア ===== */
function clearLines(){
  let c=0;
  board=board.filter(r=>{ if(r.every(v=>v)){c++;return false;} return true;});
  while(board.length<ROWS)board.unshift(Array(COLS).fill(0));
  if(c){
    const t=[0,40,100,300,1200];
    score+=t[c]*(level+1);
    lines+=c;
    level=Math.floor(lines/10);
    updateInfo();
  }
}

/* ===== 描画 ===== */
function drawGrid(){
  ctx.strokeStyle="rgba(255,255,255,0.08)";
  for(let x=0;x<=COLS;x++){ctx.beginPath();ctx.moveTo(x*BLOCK,0);ctx.lineTo(x*BLOCK,ROWS*BLOCK);ctx.stroke();}
  for(let y=0;y<=ROWS;y++){ctx.beginPath();ctx.moveTo(0,y*BLOCK);ctx.lineTo(COLS*BLOCK,y*BLOCK);ctx.stroke();}
}
function block(x,y,c,a=1){
  ctx.globalAlpha=a;
  ctx.fillStyle=c;
  ctx.fillRect(x*BLOCK,y*BLOCK,BLOCK-1,BLOCK-1);
  ctx.globalAlpha=1;
}

/* ===== ゴーストピース ===== */
function drawGhost(){
  let gy=piece.y;
  while(!collide(piece,0,gy-piece.y+1))gy++;
  piece.shape.forEach((r,y)=>
    r.forEach((v,x)=>{ if(v)block(piece.x+x,gy+y,COLORS[piece.type],0.3); })
  );
}

function draw(){
  ctx.clearRect(0,0,200,400);
  drawGrid();
  drawGhost();
  board.forEach((r,y)=>r.forEach((v,x)=>v&&block(x,y,COLORS[v])));
  piece.shape.forEach((r,y)=>r.forEach((v,x)=>v&&block(piece.x+x,piece.y+y,COLORS[piece.type])));
}

/* ===== NEXT ===== */
function drawNext(){
  const n=document.getElementById("next").getContext("2d");
  n.clearRect(0,0,80,80);
  const s=nextPiece.shape;
  const ox=(4-s[0].length)/2, oy=(4-s.length)/2;
  s.forEach((r,y)=>r.forEach((v,x)=>{
    if(v){n.fillStyle=COLORS[nextPiece.type];n.fillRect((x+ox)*20,(y+oy)*20,18,18);}
  }));
}

/* ===== UI ===== */
function updateInfo(){
  scoreEl.textContent=score;
  levelEl.textContent=level;
}

/* ===== ループ ===== */
function update(t=0){
  if(paused||gameOver){requestAnimationFrame(update);return;}
  const d=t-last; last=t; counter+=d;
  const intv=softDrop?50:Math.max(100,700-level*50);
  if(counter>intv){
    if(!collide(piece,0,1))piece.y++;
    else{
      merge(); clearLines();
      piece=nextPiece; nextPiece=newPiece(); drawNext();
      if(collide(piece,0,0)){gameOver=true;document.getElementById("over").style.display="block";}
    }
    counter=0;
  }
  draw(); requestAnimationFrame(update);
}

/* ===== 操作 ===== */
left.ontouchstart  = () => !collide(piece, -1, 0) && piece.x--;
right.ontouchstart = () => !collide(piece,  1, 0) && piece.x++;rotate.ontouchstart=tryRotate;
down.ontouchstart=()=>softDrop=true;
down.ontouchend=()=>softDrop=false;
pause.ontouchstart=()=>paused=!paused;
restart.ontouchstart=reset;

const scoreEl=document.getElementById("score");
const levelEl=document.getElementById("level");

/* ===== 起動 ===== */
reset(); update();
</script>
</body>
</html>